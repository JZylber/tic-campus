---
import CodeBlock from "../../../../../components/articles/code-block/CodeBlock.astro";

export const partial = true;
---

<h2>Origen y motivación</h2>
<p>
  Trabajar con clases trae nuevos desafíos y nuevas formas de modelar problemas.
  En particular, hay problemas conocidos con modelos de soluciones, y es acá
  donde los patrones de diseño entran en juego. Los patrones de diseño son
  soluciones reutilizables a problemas comunes en el desarrollo de software, y
  pueden ayudar a estructurar y organizar el código de manera más eficiente.
</p>
<p>
  Esta sección es un extracto y resumen del texto sagrado de la programación
  orientada a objetos: <a
    class="italic"
    href="https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns"
    >Design Patterns: Elements of Reusable Object-Oriented Software</a
  >
</p>
<h2>Herencia</h2>
<h3>¿Qué es la Herencia en clases?</h3>
<p>
  La herencia permite que una clase (llamada <strong>clase hija</strong> o <strong
    >subclase</strong
  >) tome prestados o "herede" todos los <strong>atributos</strong> y <strong
    >métodos</strong
  > de otra clase (llamada <strong>clase padre</strong> o <strong
    >superclase</strong
  >). Es como si la clase hija fuera una versión <strong>especializada</strong> de
  la clase padre.
</p>
<ul>
  <li>
    <strong>Clase Padre (Superclase):</strong> Define las características <strong
      >comunes</strong
    > y generales.
  </li>
  <li>
    <strong>Clase Hija (Subclase):</strong> Hereda lo de la padre y agrega sus propias
    características <strong>únicas</strong>.
  </li>
</ul>
<h3>Sintaxis Básica</h3>
<p>
  Para que una clase herede de otra, simplemente la ponemos entre <strong
    >paréntesis</strong
  > al definir la hija:
</p>
<CodeBlock
  lang="python"
  code={`class Vehiculo: # Clase Padre
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

    def arrancar(self):
        return f"El {self.marca} {self.modelo} está arrancando."

class Auto(Vehiculo): # Clase Hija: 'Auto' hereda de 'Vehiculo'
    def tocar_bocina(self):
        return "¡Pip Piiip!"

# ¡Miren qué fácil! Un objeto 'mi_auto' puede usar el método 'arrancar' de 'Vehiculo'
mi_auto = Auto("Renault", "12") # Alto auto
print(mi_auto.arrancar()) # Output: El Renault 12 está arrancando.`}
/>
<h3>Búsqueda de Métodos</h3>
<p>
  Cuando se llama a un método en una instancia de una clase hija, Python sigue
  un orden de búsqueda específico:
</p>
<ol>
  <li>
    <strong>Busca en la clase Hija:</strong> Primero, mira si el método está definido
    en la <strong>propia clase hija</strong>.
  </li>
  <li>
    <strong>Busca en la clase Padre:</strong> Si no lo encuentra en la hija, sube
    al toque a la <strong>clase padre</strong> (y si esa padre tiene otra padre,
    sigue subiendo la "cadena de herencia").
  </li>
</ol>

<p>
  Si el método está en la hija, lo usa; si no, sube a la padre. Si está en <strong
    >ambas</strong
  >, usa el de la <strong>hija</strong> (¡es el más específico!), esto se llama <strong
    >sobrescritura</strong
  > (<em>override</em>). Si no lo encuentra en ningún lado, ¡tira un error!
</p>
<h3>Super</h3>
<p>
  A veces, querés que la clase hija haga algo <strong>además</strong> de lo que hace
  la padre, o querés <strong>reutilizar</strong> el código de inicialización (<em
    >__init__</em
  >) de la clase padre. ¡Ahí entra en juego <em>super()</em>!
</p>

<p>
  <strong><em>super()</em></strong> te da acceso a la <strong
    >clase padre</strong
  >. El uso más común es en el método <em>__init__</em> de la hija:
</p>
<CodeBlock
  lang="python"
  code={`class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo
        print("Vehículo creado.") # Lo que hace la clase padre al inicializar

class Camioneta(Vehiculo):
    def __init__(self, marca, modelo, capacidad_carga):
        # Llama al __init__ de 'Vehiculo' para no repetir código de marca y modelo
        super().__init__(marca, modelo) 
        # Luego, agrega su atributo específico
        self.capacidad_carga = capacidad_carga
        print("Camioneta creada con extras.")

# ¡El super() hace el trabajo pesado de la inicialización de la padre!
mi_camioneta = Camioneta("Toyota", "Hilux", "1 Tonelada")
print(mi_camioneta.capacidad_carga) # Output: 1 Tonelada
# Noten que se ejecutaron los dos 'print' de los __init__`}
/>
<h2>Polimorfismo</h2>
<p>
  Dos clases son polimorficas si tienen los mismos mensajes (métodos) pero
  pueden tener implementaciones diferentes.
</p>
<p>
  Volvamos al ejemplo de los vehículos. Queremos que todos tengan la acción de <em
    >acelerar()</em
  >, pero obviamente no aceleran de la misma manera.
</p>
<CodeBlock
  lang="python"
  code={`# 1. Clase Base (Madre)
class Vehiculo:
    def __init__(self, marca):
        self.marca = marca
    
    def acelerar(self): # Método genérico
        # Esta implementación por defecto es un poco vaga, ¡pero es la base!
        print(f"El {self.marca} se está moviendo...") 

# 2. Clases Derivadas (Hijas) que SOBRESCRIBEN el método
class Auto(Vehiculo):
    # La clase Auto hereda de Vehiculo
    def acelerar(self): 
        # ¡ACÁ está el polimorfismo! Sobreescribimos el método.
        print(f"El Auto {self.marca} acelera a fondo.")

class Moto(Vehiculo):
    # La clase Moto hereda de Vehiculo
    def acelerar(self): 
        # Sobreescribimos de nuevo, con otra acción específica.
        print(f"La Moto {self.marca} levanta la rueda.")

# 3. Uso Polimórfico
# Definimos una función que no sabe QUÉ objeto va a recibir, ¡solo que tiene el método acelerar!
def probar_aceleracion(vehiculo):
    vehiculo.acelerar() # Llama al método APROPIADO para el objeto

# Instanciamos los objetos
mi_auto = Auto("Renault 12")
mi_moto = Moto("Honda Titan")

print("--- Probando Aceleración ---")
probar_aceleracion(mi_auto) # Llama al acelerar() de Auto
probar_aceleracion(mi_moto) # Llama al acelerar() de Moto`}
/>
<p>
  Aunque la función <em>probar_aceleracion()</em> siempre llama a <em
    >vehiculo.acelerar()</em
  >, el resultado cambia porque:
</p>
<ul>
  <li>
    Cuando le pasamos <em>mi_auto</em>, Python usa el <em>acelerar()</em> definido
    en la clase <strong><em>Auto</em></strong>.
  </li>
  <li>
    Cuando le pasamos <em>mi_moto</em>, Python usa el <em>acelerar()</em> definido
    en la clase <strong><em>Moto</em></strong>.
  </li>
</ul>
<p>
  <strong>¡Eso es el polimorfismo!</strong> El mismo nombre (<em>acelerar</em>)
  se comporta de distintas "formas" según el objeto
</p>, y la función puede ejecutarse con cualquier objeto que tenga el método <em
  >acelerar()</em
>.
<h2>Clases abstractas</h2>
<p>
  Una <strong>Clase Abstracta</strong> (o <em>Abstract Base Class</em>, <em
    >ABC</em
  >) es como un <strong>"contrato"</strong> o un <strong>"modelo"</strong> incompleto
  que <strong>no se puede usar directamente</strong>.
</p>

<ul>
  <li>
    <strong>No se puede instanciar:</strong> Esto significa que <strong
      >no podés crear objetos</strong
    > directamente de una clase abstracta. Si intentás hacer <em
      >mi_objeto = ClaseAbstracta()</em
    >, ¡Python te va a tirar un error!
  </li>
  <li>
    <strong>Define una interfaz:</strong> Su principal objetivo es <strong
      >definir un conjunto de métodos</strong
    > (uno o más) que <em>obligatoriamente</em> deben implementar todas las clases
    que hereden de ella. Estos son los <strong>métodos abstractos</strong>.
  </li>
</ul>

<p>
  En criollo, la clase abstracta dice: "Si sos una 'Figura', tenés que tener un
  método para calcular tu 'área', ¡sí o sí!".
</p>
<h3>¿Para qué usamos las Clases Abstractas?</h3>
<p>
  Usamos las <em>ABC</em> para lograr algo que en <em>POO</em> (Programación Orientada
  a Objetos) llamamos <strong>polimorfismo</strong> de una manera <strong
    >controlada</strong
  > y para forzar la <strong>consistencia</strong> en la estructura del código.
</p>

<ul>
  <li>
    <strong>Forzar la Implementación:</strong> Es el caso de uso principal. Asegurás
    que cualquier clase hija ("subclase") que herede del contrato <strong
      >cumpla con todos los métodos</strong
    > definidos como abstractos. Esto evita bugs y hace que el código sea más predecible.
  </li>
  <li>
    <strong>Definir Interfaces Comunes:</strong> Si tenés un sistema con varios tipos
    de objetos (ej: <em>Perro</em>, <em>Gato</em>, <em>Pez</em>) que deben
    realizar la <em>misma acción</em> (ej: <em>comer()</em>), la clase abstracta
    (<em>Animal</em>) te garantiza que todos tendrán ese método, aunque cada uno
    lo implemente a su manera. Todas las clases hijas compartirán una <strong
      >interfaz común</strong
    > y por lo tanto son polimorficas.
  </li>
  <li>
    <strong>Diseño Robusto:</strong> Al establecer este "esqueleto" de antemano,
    estás mejorando el <strong>diseño arquitectónico</strong> de tu aplicación, haciéndola
    más fácil de mantener y expandir a futuro (<em>escalabilidad</em>).
  </li>
</ul>
<h3>Ejemplo</h3>
<p>Hagamos un ejemplo con formas geométricas</p>
<CodeBlock
  lang="python"
  code={`from abc import ABC, abstractmethod

# 1. Definimos la Clase Abstracta 'FormaGeometrica'
class FormaGeometrica(ABC):
    """
    Clase abstracta que modela una forma geométrica
    y fuerza la implementación del cálculo de área.
    """

    @abstractmethod # Decorador que marca el método como obligatorio
    def calcular_area(self):
        # Un método abstracto NO tiene implementación (o puede tener una muy básica)
        pass 

    # NOTA: Podría tener métodos normales con implementación aquí
    def mostrar_info(self):
        print("Esto es una forma geométrica.")


# 2. Implementamos una Subclase 'Cuadrado'
class Cuadrado(FormaGeometrica):
    def __init__(self, lado):
        self.lado = lado
        
    # OBLIGATORIO: Debemos implementar 'calcular_area'
    def calcular_area(self):
        # Acá usamos la lógica específica del Cuadrado
        return self.lado * self.lado


# 3. Implementamos otra Subclase 'Circulo'
class Circulo(FormaGeometrica):
    def __init__(self, radio):
        self.radio = radio
        
    # OBLIGATORIO: También implementamos 'calcular_area', pero distinto
    def calcular_area(self):
        # Usamos la lógica específica del Círculo (pi * radio^2)
        return 3.14159 * self.radio * self.radio


# --- Uso en el Código ---

# a) Instanciar clases concretas (Cuadrado y Círculo)
mi_cuadrado = Cuadrado(lado=5)
mi_circulo = Circulo(radio=3)

print(f"Área del cuadrado: {mi_cuadrado.calcular_area()}") # Imprime: 25
print(f"Área del círculo: {mi_circulo.calcular_area()}") # Imprime: 28.27431
mi_cuadrado.mostrar_info() # Funciona el método de la clase abstracta


# b) Intentar instanciar la Clase Abstracta (¡ERROR!)
# forma_base = FormaGeometrica() 
# >> Esto tiraría: TypeError: Can't instantiate abstract class FormaGeometrica with abstract method calcular_area`}
/>
<p>
  Si intentás crear una clase que herede de <em>FormaGeometrica</em> (como hicimos
  con <em>Cuadrado</em> y <em>Circulo</em>), pero te <strong>olvidás</strong> de
  definir el método <em>calcular_area()</em>, <strong
    >Python no va a dejar</strong
  > crear objetos de esa nueva clase. ¡El "contrato" no fue cumplido! Y ahí está
  la magia de las clases abstractas: <strong>garantizar la estructura</strong>.
</p>
