---
import CodeBlock from "../../../../../components/articles/code-block/CodeBlock.astro";

export const partial = true;
---

<h2>Origen y motivación</h2>
<p>
  Trabajar con clases trae nuevos desafíos y nuevas formas de modelar problemas.
  En particular, hay problemas conocidos con modelos de soluciones, y es acá
  donde los patrones de diseño entran en juego. Los patrones de diseño son
  soluciones reutilizables a problemas comunes en el desarrollo de software, y
  pueden ayudar a estructurar y organizar el código de manera más eficiente.
</p>
<p>
  Esta sección es un extracto y resumen del texto sagrado de la programación
  orientada a objetos: <a
    class="italic"
    href="https://www.digitalocean.com/community/tutorials/gangs-of-four-gof-design-patterns"
    >Design Patterns: Elements of Reusable Object-Oriented Software</a
  >
</p>
<h2>Herencia</h2>
<h3>¿Qué es la Herencia en clases?</h3>
<p>
  La herencia permite que una clase (llamada <strong>clase hija</strong> o <strong
    >subclase</strong
  >) tome prestados o "herede" todos los <strong>atributos</strong> y <strong
    >métodos</strong
  > de otra clase (llamada <strong>clase padre</strong> o <strong
    >superclase</strong
  >). Es como si la clase hija fuera una versión <strong>especializada</strong> de
  la clase padre.
</p>
<ul>
  <li>
    <strong>Clase Padre (Superclase):</strong> Define las características <strong
      >comunes</strong
    > y generales.
  </li>
  <li>
    <strong>Clase Hija (Subclase):</strong> Hereda lo de la padre y agrega sus propias
    características <strong>únicas</strong>.
  </li>
</ul>
<h3>Sintaxis Básica</h3>
<p>
  Para que una clase herede de otra, simplemente la ponemos entre <strong
    >paréntesis</strong
  > al definir la hija:
</p>
<CodeBlock
  lang="python"
  code={`class Vehiculo: # Clase Padre
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

    def arrancar(self):
        return f"El {self.marca} {self.modelo} está arrancando."

class Auto(Vehiculo): # Clase Hija: 'Auto' hereda de 'Vehiculo'
    def tocar_bocina(self):
        return "¡Pip Piiip!"

# ¡Miren qué fácil! Un objeto 'mi_auto' puede usar el método 'arrancar' de 'Vehiculo'
mi_auto = Auto("Renault", "12") # Alto auto
print(mi_auto.arrancar()) # Output: El Renault 12 está arrancando.`}
/>
<h3>Búsqueda de Métodos</h3>
<p>
  Cuando se llama a un método en una instancia de una clase hija, Python sigue
  un orden de búsqueda específico:
</p>
<ol>
  <li>
    <strong>Busca en la clase Hija:</strong> Primero, mira si el método está definido
    en la <strong>propia clase hija</strong>.
  </li>
  <li>
    <strong>Busca en la clase Padre:</strong> Si no lo encuentra en la hija, sube
    al toque a la <strong>clase padre</strong> (y si esa padre tiene otra padre,
    sigue subiendo la "cadena de herencia").
  </li>
</ol>

<p>
  Si el método está en la hija, lo usa; si no, sube a la padre. Si está en <strong
    >ambas</strong
  >, usa el de la <strong>hija</strong> (¡es el más específico!), esto se llama <strong
    >sobrescritura</strong
  > (<em>override</em>). Si no lo encuentra en ningún lado, ¡tira un error!
</p>
<h3>Super</h3>
<p>
  A veces, querés que la clase hija haga algo <strong>además</strong> de lo que hace
  la padre, o querés <strong>reutilizar</strong> el código de inicialización (<em
    >__init__</em
  >) de la clase padre. ¡Ahí entra en juego <em>super()</em>!
</p>

<p>
  <strong><em>super()</em></strong> te da acceso a la <strong
    >clase padre</strong
  >. El uso más común es en el método <em>__init__</em> de la hija:
</p>
<CodeBlock
  lang="python"
  code={`class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo
        print("Vehículo creado.") # Lo que hace la clase padre al inicializar

class Camioneta(Vehiculo):
    def __init__(self, marca, modelo, capacidad_carga):
        # Llama al __init__ de 'Vehiculo' para no repetir código de marca y modelo
        super().__init__(marca, modelo) 
        # Luego, agrega su atributo específico
        self.capacidad_carga = capacidad_carga
        print("Camioneta creada con extras.")

# ¡El super() hace el trabajo pesado de la inicialización de la padre!
mi_camioneta = Camioneta("Toyota", "Hilux", "1 Tonelada")
print(mi_camioneta.capacidad_carga) # Output: 1 Tonelada
# Noten que se ejecutaron los dos 'print' de los __init__`}
/>
<h2>Polimorfismo</h2>
<p>
  Dos clases son polimorficas si tienen los mismos mensajes (métodos) pero
  pueden tener implementaciones diferentes.
</p>
<p>
  Volvamos al ejemplo de los vehículos. Queremos que todos tengan la acción de <em
    >acelerar()</em
  >, pero obviamente no aceleran de la misma manera.
</p>
<CodeBlock
  lang="python"
  code={`# 1. Clase Base (Madre)
class Vehiculo:
    def __init__(self, marca):
        self.marca = marca
    
    def acelerar(self): # Método genérico
        # Esta implementación por defecto es un poco vaga, ¡pero es la base!
        print(f"El {self.marca} se está moviendo...") 

# 2. Clases Derivadas (Hijas) que SOBRESCRIBEN el método
class Auto(Vehiculo):
    # La clase Auto hereda de Vehiculo
    def acelerar(self): 
        # ¡ACÁ está el polimorfismo! Sobreescribimos el método.
        print(f"El Auto {self.marca} acelera a fondo.")

class Moto(Vehiculo):
    # La clase Moto hereda de Vehiculo
    def acelerar(self): 
        # Sobreescribimos de nuevo, con otra acción específica.
        print(f"La Moto {self.marca} levanta la rueda.")

# 3. Uso Polimórfico
# Definimos una función que no sabe QUÉ objeto va a recibir, ¡solo que tiene el método acelerar!
def probar_aceleracion(vehiculo):
    vehiculo.acelerar() # Llama al método APROPIADO para el objeto

# Instanciamos los objetos
mi_auto = Auto("Renault 12")
mi_moto = Moto("Honda Titan")

print("--- Probando Aceleración ---")
probar_aceleracion(mi_auto) # Llama al acelerar() de Auto
probar_aceleracion(mi_moto) # Llama al acelerar() de Moto`}
/>
<p>
  Aunque la función <em>probar_aceleracion()</em> siempre llama a <em
    >vehiculo.acelerar()</em
  >, el resultado cambia porque:
</p>
<ul>
  <li>
    Cuando le pasamos <em>mi_auto</em>, Python usa el <em>acelerar()</em> definido
    en la clase <strong><em>Auto</em></strong>.
  </li>
  <li>
    Cuando le pasamos <em>mi_moto</em>, Python usa el <em>acelerar()</em> definido
    en la clase <strong><em>Moto</em></strong>.
  </li>
</ul>
<p>
  <strong>¡Eso es el polimorfismo!</strong> El mismo nombre (<em>acelerar</em>)
  se comporta de distintas "formas" según el objeto
</p>, y la función puede ejecutarse con cualquier objeto que tenga el método <em
  >acelerar()</em
>.
<h2>Clases abstractas</h2>
